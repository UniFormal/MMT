package info.kwarc.mmt.reflection
import info.kwarc.mmt.api._
import uom._
import libraries._
import modules._
import symbols._
import objects._
import utils._
import frontend._
import objects.Conversions._
/*import scala.collection.immutable.Stack */

/* ***************************** Syntax (generated by UOM) *********************************** */

object Terms extends TheoryScalaAux {
  val _base = DPath(utils.URI("http", "cds.omdoc.org") / "urtheories" / "reflection")
  val _path = _base ? "Terms"

  object formation extends ConstantScala {
    val parent = _path
    val name = "formation"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object refl extends ConstantScala {
    val parent = _path
    val name = "refl"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object eval extends ConstantScala {
    val parent = _path
    val name = "eval"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }


  object elim extends ConstantScala {
    val parent = _path
    val name = "elim"
    def apply(x1: Term, x2: Term) = OMA(OMID(this.path), x1 :: x2:: Nil)
    def unapply(t: Term): Option[(Term, Term)] = t match {
      case OMA(OMID(this.path), x1 :: x2:: Nil) => Some((x1, x2))
      case _ => None
    }
  }
}

/* ***************************** Typing Rules *********************************** */

object TermFormationInfer extends InferenceRule(Terms.formation.path, OfType.path) {
   def apply(solver: Solver)(tm: Term)(implicit stack: Stack): Option[Term] =
     tm match {
       case Terms.formation(s,a) =>
          solver.inferType(a) map {t => t}
       case _ => None
     }
 }

object TermReflInfer extends InferenceRule(Terms.refl.path, OfType.path) {
  def apply(solver: Solver)(tm: Term)(implicit stack: Stack): Option[Term] =
    tm match {
       case Terms.refl(s,t) => solver.inferType(t)
       case _ => None
     }
 }

object TermElimInfer extends InferenceRule(Terms.elim.path, OfType.path){
  implicit def pCont(p:Path){}
  def apply(solver: Solver)(tm: Term)(implicit stack : Stack) : Option[Term] = {
     tm match {
       case Terms.elim(q,mor) =>
         if(!stack.frames.isEmpty) {
           solver.inferType(q) match {
            case None => None
            case Some(Terms.formation(s,a)) => Some(solver.controller.checker.checkMorphism(mor,s,stack.theory))
            case _ => None
           }
         }
         else None
       case _ => None
     }
   }
 }

/* Computation Rules for Reflected Terms */

object ComputationReflectionRule extends ComputationRule(Reflection.elim){
 implicit def pCont(p:Path){}
 implicit val stack = Stack(List())
 def apply(solver: Solver)(tm: Term)(implicit stack : Stack) : Option[Term] = {
   tm match {
     case Elim(TermRefl(s,t),mor) =>
       if(!stack.frames.isEmpty) {
        try {
          solver.checkMorphism(mor,s)
        }
        catch {
         case e:Error => false
        }
       Some(OMA(mor,List(t)))
       }
       else None
     case _ => None
 }
 }
}

object SoundnessReflectionRule extends ComputationRule(Reflection.eval){
  def apply(solver: Solver)(tm: Term)(implicit stack: Stack) : Option[Term] = {
    tm match {
      case TermEval(s1,TermRefl(s2,t)) =>
        if (s1 == s2)
           Some(t)
        else
           None
      case _ => None
    }
  }
}

object CompletenessReflectionRule extends ComputationRule(Reflection.intro){
  def apply(solver: Solver)(tm: Term)(implicit stack: Stack) : Option[Term] = {
    tm match {
      case TermRefl(s1,TermEval(s2,t)) =>
        if (s1 == s2) {
          solver.inferType(tm) match {
            case Some(ReflType(s,a)) => s == s2
            case _ => false
        }
        Some(t)
        }
        else None
      case _ => None
    }
  }
}

/* Equality Rule for Reflected Terms */

object ExtensionalityReflectionRule extends EqualityRule(Reflection.intro){
  def apply(solver: Solver)(tm1: Term, tm2: Term, tp: Term)(implicit stack: Stack) : Boolean = {
    (tm1,tm2) match {
      case (TermRefl(s1,t1),TermRefl(s2,t2)) =>
        if (s1 == s2) {
          solver.checkEquality(TermEval(s1,t1),TermEval(s2,t2),None)
        }
        else false
      case (_,_) => false
    }
  }
}


/* Solution Rules for Reflected Terms */

object SolveEvalReflectionRule extends SolutionRule(Reflection.eval){
  def apply(solver: Solver)(tm1: Term, tm2: Term)(implicit stack : Stack) : Boolean = {
    tm1 match {
      case TermEval(s,x) => solver.checkEquality(x,TermRefl(s,tm2),None)
      case _ => false
    }
  }
}

object SolveReflReflectionRule extends SolutionRule(Reflection.intro){
  def apply(solver: Solver)(tm1: Term, tm2: Term)(implicit stack : Stack) : Boolean = {
    tm1 match {
      case TermRefl(s,x) => solver.checkEquality(x,TermEval(s,tm2),None)
      case _ => false
    }
  }
}

/* Type Checking Rules for Reflected Terms */

object ReflTypingRule extends TypingRule(Reflection.rtype){
  def apply(solver: Solver)(tm: Term, tp: Term)(implicit stack : Stack) : Boolean = {
    tp match {
      case ReflType(s,a) => solver.checkTyping(TermEval(s,tm),a)
      case _ => false
    }
  }
}
