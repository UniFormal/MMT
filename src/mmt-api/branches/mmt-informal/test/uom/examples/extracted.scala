//Source file generated by the Universal OpenMath Machine

import info.kwarc.mmt.api._
import info.kwarc.mmt.api.objects._
import info.kwarc.mmt.uom.Implementation
package org.openmath.www.cd
{
class arith1 {
  val base = DPath(utils.URI("http", "www.openmath.org") / "cd")
  val gcd = OMID(base ? "arith1" ? "gcd")

  // UOM start http://www.openmath.org/cd?arith1?gcd
  def gcd(l : Term*) : Term = { def gcd_bin_num(a : BigInt, b : BigInt) : BigInt = if (b == 0) a else gcd_bin_num(b, a%b); def arith(l : Term*) : BigInt = { l.toList match { case OMI(i) :: Nil => i case OMI(i) :: tl => gcd_bin_num(i, arith(tl :_*)) case _ => throw new Exception("gcd works with at least 1 OMI") } }; return OMI(arith(l :_*)) }
  // UOM end

  def gcd_*(l : Term*) : Term  = {
    return gcd(l : _*)
  }

  val gcd_** = new Implementation(
    base ? "arith1" ? "gcd"
    ,
    gcd_*
    )

  val lcm = OMID(base ? "arith1" ? "lcm")

  // UOM start http://www.openmath.org/cd?arith1?lcm
  def lcm(l : Term*) : Term = { def gcd_bin_num(a : BigInt, b : BigInt) : BigInt = if (b == 0) a else gcd_bin_num(b, a%b); def lcm2(i : BigInt, j : BigInt) : BigInt = i*j/(gcd_bin_num(i,j)); def arith(l : Term*) : BigInt = { l.toList match { case OMI(i) :: Nil => i case OMI(i) :: tl => lcm2(i, arith(tl :_*)) case _ => throw new Exception("lcm works with at least 1 OMI") } }; return OMI(arith(l :_*)) }
  // UOM end

  def lcm_*(l : Term*) : Term  = {
    return lcm(l : _*)
  }

  val lcm_** = new Implementation(
    base ? "arith1" ? "lcm"
    ,
    lcm_*
    )

  val plus = OMID(base ? "arith1" ? "plus")

  // UOM start http://www.openmath.org/cd?arith1?plus
  def plus(l : Term*) : Term = { def arithm(l : Term*) : Double = { l.toList match { case Nil => 0 case OMF(x) :: tl => x + arithm(tl :_*) case _=> throw new Exception("plus works only with OMFs") } }; return OMF(arithm(l :_*)) }
  // UOM end

  def plus_*(l : Term*) : Term  = {
    return plus(l : _*)
  }

  val plus_** = new Implementation(
    base ? "arith1" ? "plus"
    ,
    plus_*
    )

  val unary_minus = OMID(base ? "arith1" ? "unary_minus")

  // UOM start http://www.openmath.org/cd?arith1?unary_minus
  def unary_minus(x : Term) : Term = { x match { case OMF(y) => OMF(-y) case _=> throw new Exception("minus expects exactly 1 OMF") } }
  // UOM end

  def unary_minus_*(l : Term*) : Term  = {
    return unary_minus(l(0))
  }

  val unary_minus_** = new Implementation(
    base ? "arith1" ? "unary_minus"
    ,
    unary_minus_*
    )

  val minus = OMID(base ? "arith1" ? "minus")

  // UOM start http://www.openmath.org/cd?arith1?minus
  def minus(x : Term, y : Term) : Term = { (x,y) match { case (OMF(x1), OMF(y1)) => OMF(x1 - y1) case _=> throw new Exception("minus expects exactly 2 OMFs") } }
  // UOM end

  def minus_*(l : Term*) : Term  = {
    return minus(l(0), l(1))
  }

  val minus_** = new Implementation(
    base ? "arith1" ? "minus"
    ,
    minus_*
    )

  val times = OMID(base ? "arith1" ? "times")

  // UOM start http://www.openmath.org/cd?arith1?times
  def times(l : Term*) : Term = { def arithm(l : Term*) : Double = { l.toList match { case Nil => 1 case OMF(x) :: tl => x * arithm(tl :_*) case _=> throw new Exception("times works only with OMFs") } }; return OMF(arithm(l :_*)) }
  // UOM end

  def times_*(l : Term*) : Term  = {
    return times(l : _*)
  }

  val times_** = new Implementation(
    base ? "arith1" ? "times"
    ,
    times_*
    )

  val divide = OMID(base ? "arith1" ? "divide")

  // UOM start http://www.openmath.org/cd?arith1?divide
  def divide(x : Term, y : Term) : Term = { (x,y) match { case (_, OMF(0)) => throw new Exception("division by zero in minus") case (OMF(x1), OMF(y1)) => OMF(x1 / y1) case _=> throw new Exception("divide expects exactly 2 OMFs") } }
  // UOM end

  def divide_*(l : Term*) : Term  = {
    return divide(l(0), l(1))
  }

  val divide_** = new Implementation(
    base ? "arith1" ? "divide"
    ,
    divide_*
    )

  val power = OMID(base ? "arith1" ? "power")

  // UOM start http://www.openmath.org/cd?arith1?power
  def power(x : Term, y : Term) : Term = { (x,y) match { case (OMF(x1), OMF(y1)) => OMF(scala.math.pow(x1, y1)) case _=> throw new Exception("power expects exactly 2 OMFs") } }
  // UOM end

  def power_*(l : Term*) : Term  = {
    return power(l(0), l(1))
  }

  val power_** = new Implementation(
    base ? "arith1" ? "power"
    ,
    power_*
    )

  val abs = OMID(base ? "arith1" ? "abs")

  // UOM start http://www.openmath.org/cd?arith1?abs
  def abs(x : Term) : Term = { x match { case OMF(y) => OMF(scala.math.abs(y)) case _=> throw new Exception("abs expects exactly 1 OMF") } }
  // UOM end

  def abs_*(l : Term*) : Term  = {
    return abs(l(0))
  }

  val abs_** = new Implementation(
    base ? "arith1" ? "abs"
    ,
    abs_*
    )

  val root = OMID(base ? "arith1" ? "root")

  // UOM start http://www.openmath.org/cd?arith1?root
  def root(x : Term, y : Term) : Term = { (x,y) match { case (OMF(x1), OMF(y1)) => OMF(scala.math.pow(x1, 1/y1)) case _=> throw new Exception("root expects exactly 2 OMFs") } }
  // UOM end

  def root_*(l : Term*) : Term  = {
    return root(l(0), l(1))
  }

  val root_** = new Implementation(
    base ? "arith1" ? "root"
    ,
    root_*
    )

}
}

