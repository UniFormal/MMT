package info.kwarc.mmt.api.uom

import info.kwarc.mmt.api._
import objects._
import modules._
import symbols._

/**
 * a model of an MMT theory in Scala
 */
abstract class RealizationInScala extends DeclaredTheory(null, null, None) {
   // getClass only works inside the body, i.e., after initializing the super class
   // so we make the constructor arguments null and override afterwards
   // this will fail if one of the arguments is accessed during initialization of the superclass
   override val parent = GenericScalaExporter.scalaToDPath(getClass.getPackage.getName)
   override val name = {
      val cls = getClass
      var n = cls.getName.substring(cls.getPackage.getName.length+1)
      if (n.endsWith("$"))
         n = n.substring(0,n.length-1)
      LocalName(n)
   }
   
   /** the modelled theory */
   val _domain: TheoryScala
   
   /** the MMT URI of the modelled theory */
   lazy val _path = _domain._path
   /** the name of the modelled theory */
   lazy val _name = _domain._name

   /** the body of this theory
    *  
    *  this is maintained lazily so that it can be built by the initializer of inheriting classes
    *  see the classes generated by [[uom.ScalaExporter]] for examples
    */
   private var _lazyBody : List[() => Declaration] = List(() => symbols.PlainInclude(_path, path))
   
   /**
    * adds a [[RealizedTypeConstant]] to this model
    */
   def declares(synType: GlobalName)(rtL: () => RealizedType) {
      val dL = () => {
         val rt = rtL()
         if (rt.synType == null) rt.init(synType, path) // included RealizedTypes are already initialized
         val rc = new RealizedTypeConstant(toTerm, synType.name, rt)
         rc
      }
      _lazyBody ::= dL
   }
   /**
    * add a [[RuleConstant]] realizing r.head as r to this model
    * @param r a BreadthRule for n-ary operators and an AbbrevRule for nullary operators
    */
   def declares(r: => uom.UOMRule) {
      val dL = () => new symbols.RuleConstant(toTerm, r.head.name, r)
      _lazyBody ::= dL
   }
   
   /**
    * creates the actual body of this class from the lazy body
    */
   def init {
      _lazyBody.reverseMap {dL => add(dL())}
      _lazyBody = Nil // make sure, nothing gets added twice
   }
   
   private var _axioms: List[(String, Unit => Term, Term => Boolean)] = Nil
   def _assert(name: String, term: Unit => Term, assertion: Term => Boolean) {_axioms ::= ((name, term, assertion))}
   def _test(controller: frontend.Controller, log: String => Unit) {
      _axioms.foreach {
         case (n, tL, a) =>
           log("test case " + n)
           try {
             val t = tL()
             //log("term: " + controller.presenter.asString(t))
             val tS = controller.simplifier(t, Context(_path))
             //log("simplified: " + controller.presenter.asString(tS))
             val result = a(tS)
             log((if (result) "PASSED" else "FAILED") + "\n")
           } catch {
             case Unimplemented(f) => log("unimplemented " + f + "\n")
             case e: Error => log("error :" + e.toString + "\n")
           }
      }
   }
}

trait TheoryScala {
   val _base : DPath
   val _name : LocalName
   lazy val _path = _base ? _name
}

trait ConstantScala {
   val parent: MPath
   val name: String
   lazy val path: GlobalName = parent ? name
   lazy val term = objects.OMID(path)
}

trait ViewScala extends TheoryScala

object ConstantScala {
   implicit def constantToTerm(c: ConstantScala) = c.term
}

trait DocumentScala {
   private var realizations: List[RealizationInScala] = Nil
   private var documents : List[DocumentScala] = Nil
   def addRealization(r: RealizationInScala) {
      realizations ::= r
   }
   def addDocument(d: DocumentScala) {
      documents ::= d
   }
   def test(controller: frontend.Controller, log: String => Unit) {
      documents.foreach {_.test(controller, log)}
      realizations.foreach {_._test(controller, log)}
   }
}

