//Source file generated by the Universal OpenMath Machine

import info.kwarc.mmt.api._
import info.kwarc.mmt.api.objects._
import info.kwarc.mmt.uom.Implementation
package org.omdoc.cds.unsorted.uom.omdoc
{
class lists {
  val base = DPath(new utils.xml.URI("http://cds.omdoc.org/unsorted/uom.omdoc"))

  val elem = OMID(GlobalName(OMMOD(MPath(base, LocalPath(List(
    "lists")))), LocalName(List(NamedStep("elem")))))
  val list = OMID(GlobalName(OMMOD(MPath(base, LocalPath(List(
    "lists")))), LocalName(List(NamedStep("list")))))
  val nil = OMID(GlobalName(OMMOD(MPath(base, LocalPath(List(
    "lists")))), LocalName(List(NamedStep("nil")))))
  val cons = OMID(GlobalName(OMMOD(MPath(base, LocalPath(List(
    "lists")))), LocalName(List(NamedStep("cons")))))
  val append = OMID(GlobalName(OMMOD(MPath(base, LocalPath(List(
    "lists")))), LocalName(List(NamedStep("append")))))

  // UOM start http://cds.omdoc.org/unsorted/uom.omdoc?lists?append_*
  def append_*(l: Term, m: Term) : Term = { l match { case this.nil => m; case OMA(this.cons, List(this.elem, rest)) => OMA(this.cons, List(this.elem, append_*(rest, m)) ); case _ => throw new Exception("malformed term"); } }
  //I have added this line from VIM
  val append_* = Implementation(base ? "append_*") {
     case Arguments(l, m) => 
        l match {
           case this.nil => m
           case OMA(this.cons, List(this.elem, rest)) => OMA(this.cons, List(this.elem, append_*(rest, m)) )
           case _ => throw new Exception("malformed term"); } }
  }
  // UOM end

  def append_**(l : Term*) : Term  = {
    return append_*(l(0), l(1))
  }

  val append_*** = new Implementation(
    GlobalName(OMMOD(MPath(base, LocalPath(List(
    "lists")))), LocalName(List(NamedStep("append_*"))))
    ,
    append_**
    )

}
}

package org.omdoc.cds.unsorted.uom.omdoc
{
class lists_ext {
  val base = DPath(new utils.xml.URI("http://cds.omdoc.org/unsorted/uom.omdoc"))

  val append_many = OMID(GlobalName(OMMOD(MPath(base, LocalPath(List(
    "lists_ext")))), LocalName(List(NamedStep("append_many")))))

  // UOM start http://cds.omdoc.org/unsorted/uom.omdoc?lists_ext?append_many_*
  def append_many_*(l: Term*) : Term = { val lists = new org.omdoc.cds.unsorted.uom.omdoc.lists; l.toList match { case Nil => lists.nil case hd :: tl => lists.append_*(hd, append_many_*(tl : _*)) } }
  // UOM end

  def append_many_**(l : Term*) : Term  = {
    return append_many_*(l : _*)
  }

  val append_many_*** = new Implementation(
    GlobalName(OMMOD(MPath(base, LocalPath(List(
    "lists_ext")))), LocalName(List(NamedStep("append_many_*"))))
    ,
    append_many_**
    )

}
}

