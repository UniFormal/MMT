%*
   An older version of model theory for propositional logic.
   @author Fulya Horozal, Florian Rabe
   @license LATIN
*%

%namespace "http://cds.omdoc.org/logics/propositional/classic/model_theory_old/mod.elf".
%namespace sttifol = "../../../meta/sttifol.elf".
%namespace bool    = "../../../meta/bool.elf".


%sig Base = {
  %include sttifol.STTIFOLEQ %open.	
  %include bool.Bool %open.
}.

%sig Truth = {
  %include sttifol.STTIFOLEQ %open.	
  %include Base %open.
  true'  : bool.
  true1  : ded true' eq 1.
}.

%sig Falsity = {
  %include sttifol.STTIFOLEQ %open.	 
  %include Base %open.
  false' : bool.
  false0 : ded false' eq 0.
}.

%sig NEG = {
  %include sttifol.STTIFOLEQ %open.	 
  %include Base   %open.
  not'  : elem (bool' → bool').
  not1  : ded ((A eq 0) imp ((not' @ A) eq 1)).
  not0  : ded ((A eq 1) imp ((not' @ A) eq 0)).
  
  not'' : bool -> bool 
        = [A] not' @ A.  
  not1' : ded (A eq 0) -> ded (not'' A) eq 1
        = [p] impE not1 p.
  not0' : ded A eq 1   -> ded (not'' A) eq 0
        = [p] impE not0 p.
}.

%sig DISJ = {
  %include sttifol.STTIFOLEQ %open.	
  %include Base %open.
  or'  : elem (bool' → bool' → bool').
  or1 : ded (((A eq 1) or (B eq 1)) imp (((or' @ A) @ B) eq 1)).
  or0 : ded (((A eq 0) and (B eq 0)) imp (((or' @ A) @ B) eq 0)).
 
  or'' : bool -> bool -> bool
       = [A][B] or' @ A @ B.               %infix left 10 or''.
  or1' : ded (A eq 1) or  (B eq 1) -> ded (A or'' B) eq 1
       = [p] (orE p 
                  ([q : ded (A eq 1)] impE or1 p) 
                  ([r : ded (B eq 1)] impE or1 p)).
  or0' : ded (A eq 0) and (B eq 0) -> ded (A or'' B) eq 0
       = [p] impE or0 p.
}.

%sig CONJ = {
  %include sttifol.STTIFOLEQ %open.
  %include Base %open.
  and'  : elem (bool' → bool' → bool').
  and1 : ded (((A eq 1) and (B eq 1)) imp (((and' @ A) @ B) eq 1)).
  and0 : ded (((A eq 0) or  (B eq 0)) imp (((and' @ A) @ B) eq 0)).
 
  and'' : bool -> bool -> bool 
        = [A][B] and' @ A @ B.                %infix left 10 and''.
       
  and1' : ded A eq 1 and B eq 1 -> ded (A and'' B) eq 1
        = [p] impE and1 p. 
  and0' : ded A eq 0 or  B eq 0 -> ded (A and'' B) eq 0
        = [p] impE and0 p.
  and1'': ded (A and'' B) eq 1 -> ded A eq 1 and B eq 1 
        = [p] andI (not-boole1 (andEl (deMorgan_or (contrapos and0 (boole-not1 p)))))
                   (not-boole1 (andEr (deMorgan_or (contrapos and0 (boole-not1 p))))).
}.

%sig IMP = {
  %include sttifol.STTIFOLEQ %open.
  %include Base %open.
  imp' : elem (bool' → bool' → bool').
  imp1 : ded (((A eq 0) or  (B eq 1)) imp (((imp' @ A) @ B) eq 1)).
  imp0 : ded (((A eq 1) and (B eq 0)) imp (((imp' @ A) @ B) eq 0)).
 
  imp'' : bool -> bool -> bool
         = [A][B] (imp' @ A) @ B.      %infix right 15 imp''.
  imp1' : ded A eq 0 or  B eq 1 -> ded (A imp'' B) eq 1 
         = [p] impE imp1 p.
  imp0' : ded A eq 1 and B eq 0 -> ded (A imp'' B) eq 0
         = [p] impE imp0 p.
}.

%sig PL = {
 %include sttifol.STTIFOLEQ   %open.	
 %include Base     %open.
 %include Truth    %open.
 %include Falsity  %open.
 %include NEG      %open.
 %include DISJ     %open.
 %include CONJ     %open.
 %include IMP      %open.
}.