package info.kwarc.mmt.uom
import info.kwarc.mmt.api._
import info.kwarc.mmt.api.frontend._
import info.kwarc.mmt.api.modules._
import info.kwarc.mmt.api.symbols._
import info.kwarc.mmt.api.utils.MyList._
import info.kwarc.mmt.api.objects._
import java.io._

object Extractor extends {
   val report = new frontend.FileReport(new java.io.File("uom.log"))
   val checker = new libraries.FoundChecker(libraries.DefaultFoundation)} with Controller(checker, report) {

   /* Create unique package name for the OMDoc document */
   def UriToPackage(str : String) : String = {
     var result = "package "
     
     var packageName : java.lang.String = str
     packageName = packageName.trim
     packageName = packageName.substring(packageName.indexOf("//") + 2)  // remove protocol part
     var webPart = packageName.substring(0 , packageName.indexOf("/"))   // domain address part of URI
     var localPath = packageName.substring(packageName.indexOf("/") +1)    // local name in the domain

     /* print the reversed domain part to file  */
     var reverseBase = webPart.split("[.]")
     for (i <- 0 to reverseBase.length-1)
       result += (reverseBase(reverseBase.length -1 - i) + ".")

     /* in the local name part replace the / with . */
     localPath = localPath.replace('/', '.')

     result += (localPath + "\n")
     result
   }

   def doTheory(t: DeclaredTheory) {
     println("Handling theory \"" + t.name  +  "\"")
     var out = new PrintWriter(new BufferedWriter(new FileWriter("extracted.scala", true))); //open and append
     out.println(UriToPackage(t.parent.toString) + "{")
     out.println("class " + t.name + " {")
     out.println("  private val base = DPath(new utils.xml.URI(\"" + t.parent.toString  + "\"))\n")
	   t.valueList map {
	      case c: Constant =>  // handle constants here
          c.df match {
            case Some(term) => { 
              term match {
                case OMFOREIGN(node) => {
                  out.println("\n  // UOM start " + c.path.toString)
                  out.println("  "+node.text)
                  out.println("  // UOM end\n")
                }
                case _ => out.println("  val " + c.name + " = OMS(SPath(MPath(base, LocalPath(List(\"" + 
                  t.name + "\"))), LocalPath(List(\"" + c.name + "\"))))")
              }
            }
            case None => out.println("  val " + c.name + " = OMS(SPath(MPath(base, LocalPath(List(\"" + 
                  t.name + "\"))), LocalPath(List(\"" + c.name + "\"))))")
          }
          
	      case PlainInclude(from, to) => {
          out.println("  val " + from.name.flat + " = new " + from.name.flat) // handle includes here
          
        }
	      // case s: Structure => // TODO later
	      case _ => 
	   }
     println("Done with that theory\n\n")
     out.println("}\n}\n")
     out.close
   }

   def main(args: Array[String]) {
     if (args.length != 2) {
       println("The program should accept exactly 2 arguments")
       return;
     }

	   handle(Local)
	   val file = utils.xml.URI(new java.io.File(args(0)).toURI) // physical location of the file
	   handle(Read(DPath(file)))
	   val dpath = Path.parseD(args(1), base) // semantic identifier of the document (given by base attribute)
	   
	   val doc = try {docstore.get(dpath)} // get the content of the document as a list of reference elements
	             catch {case NotFound(p) => println(p.toPath + " not found"); exit}
	   val theos : List[DeclaredTheory] =  // dereference all and keep the theories
	  	   doc.getItems mapPartial {r => get(r.target) match {
	  	  	   case t : DeclaredTheory => Some(t)
	  	  	   case _ => None
	  	   }
	   }

     var out = new PrintWriter(new BufferedWriter(new FileWriter("extracted.scala", false))); // open and overwrite
     out.println("//Source file generated by the Universal OpenMath Machine\n")

//     out.println(UriToPackage(args(1)))

     out.println("import info.kwarc.mmt.api._")
     out.println("import info.kwarc.mmt.api.objects._\n") // handle initial imports

     out.close    //TODO some exception handling

	   theos foreach doTheory // handle all theories
   }
   
}


