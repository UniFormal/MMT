package info.kwarc.mmt.jedit

import errorlist._
import info.kwarc.mmt.api._
import archives.source
import frontend._
import objects._
import org.gjt.sp.jedit.jEdit
import parser._
import utils.MyList._
import utils._

/** customizes the default errors of the ErrorList plugin
 *  @param mainFile the file whose checking led to the error (may differ from the file that contains the error)
 */
class MMTError(val mainFile: File, es: ErrorSource, el: Level.Level, sf: String, sl: Int, sc: Int, ec: Int, msg: String, extraMsg: List[String])
   extends DefaultErrorSource.DefaultError(es, MMTError.mmtLevelTojEditLevel(el), sf, sl, sc, ec, msg) {
  extraMsg foreach {m => addExtraMessage(m)}
}

object MMTError {
  def apply(mainFile: File, es: ErrorSource, e: Error, sf: String, reg: SourceRegion, msg: String, extraMsg: List[String]) = {
     val pos = reg.start
     try {
       val (line,column) = if (pos.line == -1 || pos.column == -1) {
         // unknown line/column: compute from offset
         val buf = jEdit.getBuffer(mainFile.toString) //TODO does this actually find the buffer?
         val l = buf.getLineOfOffset(pos.offset)
         (l, pos.offset-buf.getLineStartOffset(l))
       } else
         (pos.line,pos.column)
       new MMTError(mainFile, es, e.level, sf, line, column, column + reg.length, msg, extraMsg)
     } catch {
       case t: Exception =>
         val tMsg = "error while creating error (illegal region?: " + reg + ")" 
         new MMTError(mainFile, es, e.level, sf, 0, 0, 1, tMsg, msg :: extraMsg)
     }
  }
  def mmtLevelTojEditLevel(mmtLevel: Level.Level): Int = if (mmtLevel >= Level.Error) ErrorSource.ERROR else ErrorSource.WARNING
}
   
/** customizes the default error source of the ErrorList plugin */
class MMTErrorSource extends DefaultErrorSource("MMT") {

   /** like superclass but allows only [[MMTError]]s */
   override def addError(e: DefaultErrorSource.DefaultError) {
      e match {
        case e: MMTError => super.addError(e)
        case _ => throw ImplementationError("illegal error")
      }
   }

   /** remove errors produced when checking this file */
   def removeFileErrors(file: File) {
     val sets = errors.values.iterator
     while (sets.hasNext) {
       val set = sets.next
       val es = set.iterator
       var remove: List[MMTError] = Nil
       while (es.hasNext) {
          es.next match {
            case e: MMTError =>
               if (e.mainFile == file) {
                 remove ::= e
               }
            case e =>
               // should be impossible
          }
       }
       remove.foreach {e =>
          set.remove(e)
          gui.Swing.invokeLater {
            val msg = new ErrorSourceUpdate(this, ErrorSourceUpdate.ERROR_REMOVED, e)
            org.gjt.sp.jedit.EditBus.send(msg)
          }
       }
     }
   }
}

/**
 * sends MMT errors directly to jEdit ErrorList
 * @param mainFile the source file, in which the errors are found
 */
class ErrorListForwarder(errorSource: MMTErrorSource, controller: Controller, mainFile: File) extends ErrorHandler {
   /**
    * remove all errors whose mainFile is src
    */
   private var errors : Array[ErrorSource.Error] = Array()
   override def reset {
      errorSource.removeFileErrors(mainFile)
      errors = Array()
     super.reset
   }
   protected def addError(e: Error) : Unit = e match {
      case s: SourceError =>
         //generated by parsers
         // We permit the case that errors are found in other files than the current one. So we compute the file path
         val file = controller.backend.resolveLogical(s.ref.container) match {
            case Some((a, p)) => (a / source / p).toString
            case None => s.ref.container match {
               case utils.FileURI(f) => f.toString
               case u => u.toString
            }
         }
         val error = MMTError(mainFile, errorSource, s, file, s.ref.region, s.mainMessage, s.extraMessages)
         errorSource.addError(error)
      case e: Invalid =>
         //generated by checkers
         var mainMessage = e.shortMsg
         var extraMessages : List[String] = e.extraMessage.split("\n").toList
         val causeOpt: Option[metadata.HasMetaData] = e match {
            case e: InvalidObject => Some(e.obj)
            case e: InvalidElement => Some(e.elem)
            case e: InvalidUnit =>
               val steps = e.history.getSteps
               extraMessages :::= steps.map(_.present(o => controller.presenter.asString(o)))
               val declOpt = e.unit.component.map(p => controller.localLookup.get(p.parent))
               // WFJudgement must exist because we always start with it
               // find first WFJudgement whose region is within the failed checking unit
               declOpt flatMap {decl =>
                  SourceRef.get(decl).flatMap {bigRef =>
                     steps.mapFind {s => 
                       s.removeWrappers match {
                        case j: WFJudgement =>
                           SourceRef.get(j.wfo) flatMap {smallRef =>
                              if (bigRef contains smallRef) {
                                 mainMessage += ": " + controller.presenter.asString(j.wfo)
                                 Some(j.wfo)
                              } else
                                 None
                           }
                        case _ =>
                          None
                       }
                     }
                  }.orElse(declOpt)
               }
         }
         extraMessages :::= e.getAllCausedBy.map(_.toString)
         val ref = causeOpt.flatMap {cause => SourceRef.get(cause)}.getOrElse {
            mainMessage = "error with unknown location: " + mainMessage
            SourceRef(utils.FileURI(mainFile), SourceRegion(SourcePosition(0,0,0), SourcePosition(0,0,0)))
         }
         val error = MMTError(mainFile, errorSource, e, mainFile.toString, ref.region, mainMessage, extraMessages)
         errorSource.addError(error)
      case e: Error =>
         // other errors, should not happen
         val msg =  "error with unknown location: " + e.getMessage
         val error = new MMTError(mainFile, errorSource, e.level, mainFile.toString, 0, 0, 1, msg, stringToList(e.toStringLong,"\n"))
         errorSource.addError(error)
   }
}
