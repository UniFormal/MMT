package info.kwarc.mmt.lf.itp

import info.kwarc.mmt.api.MPath
import info.kwarc.mmt.api.checking.{History, Solver}
import info.kwarc.mmt.api.objects.{Inhabitable, Stack, Typing}
import info.kwarc.mmt.api.proving.itp._

import scala.collection.mutable.ListBuffer

/**
  * a proof manager (here called [[InteractiveProof]]) manages a proof and its meta
  * @param s the solver used for this proof
  * @param p the actual proof (i.e. a collection of goals and its contexts)
  * @param mpath the mmt path of this proof
  */
class InteractiveProof(s : Solver , p : Proof , mpath : Option[MPath],  generateProofTermInit : Boolean = true ){
  var testrun : Boolean = false
  var pr : Proof  = p
  var slvr : Solver = s
  val tp = new TacticParser(this)
  val mp = mpath
  val steps : ListBuffer[Tactic]= ListBuffer()
  val stepsS : ListBuffer[String] = ListBuffer()
  var generateProofTerm : Boolean = generateProofTermInit
  def dontGenerateProofTerm : Boolean = ! generateProofTerm
  /**
    * the history saves previous proof steps used for undo-actions
    */
  val history : ListBuffer[Proof ]  = ListBuffer()
  val hist = new History(Nil)

  /**
    * saves the current proof state in the history
    */
  def saveCurrState = {
    val old = pr.copy
    slvr.currentStateObj.saveCurrentState()
    history.insert(0 , old)
  }

  /**
    * executes a tactics , undos the state changes coused by the tactic if it fails
    * @param t the tactic to be executed
    * @return the potential warning/error message generated by the tactic
    */
  def executeStep(t : Tactic): Msg ={
    // execute the tactic
    val ret = try {
      t.applyToProof(pr, this)
    }catch
    {
      case e => HasError(e.getStackTrace.mkString("\n"))
    }
    val dbg1 = ()
    if(testrun) {
      ret match {
        case HasError(s) => undo ; return ret
        case _ =>
      }
      val ret1 = if (slvr.getErrors.nonEmpty) {
        val errs = slvr.getErrors; undo; return ret.combineMsg(HasError(errs.mkString("\n")))
      } else ret

      val ret2 = if (slvr.getConstraints.nonEmpty) {
        val msg = slvr.getConstraints.toString(); undo; return ret1.combineMsg(HasError("could not solve constrains " + msg))
      } else ret1
      val dbg = ()
      ret2 match {
        case NoMsg() | WarningMsg(_) => ret2
        case HasError(_) => undo; ret2
      }
    }else {

      val ret0 = ret match {
        case NoMsg() | WarningMsg(_) => {
          try {
            pr.updateProofTerm(slvr); ret
          } catch {
            case e => HasError(e.getStackTrace.mkString("\n"))
          }
        }
        case HasError(s) => {
          undo
          return ret

        }
      }
      val ret1 = if (slvr.getErrors.nonEmpty) {
        val errs = slvr.getErrors; undo; return ret0.combineMsg(HasError(errs.mkString("\n")))
      } else ret0
      val ret2 = if (slvr.getConstraints.nonEmpty) {
        val msg = slvr.getConstraints.toString(); undo; return ret1.combineMsg(HasError("could not solve constrains " + msg))
      } else ret1
      val ukmsg0 = pr.updateUnknowns(slvr).combineMsg(ret2)
      val ukmsg1 = if (pr.currentState.isEmpty) {
        val bl = slvr.check(Typing(Stack(slvr.checkingUnit.context), pr.proofTermAlt, pr.initGoal))(hist)
        if (bl && slvr.getErrors.isEmpty && slvr.getUnsolvedVariables.isEmpty) {
          ukmsg0
        } else {
          HasError("solution doesn't check out").combineMsg(ukmsg0)
        }
      } else ukmsg0
      val ukmsg2 = if (pr.currentState.isEmpty) {
        val bl = slvr.check(Typing(Stack(slvr.checkingUnit.context), pr.proofTerm, pr.initGoal))(hist)
        if (bl && slvr.getErrors.isEmpty && slvr.getUnsolvedVariables.isEmpty) {
          ukmsg1
        } else {
          HasError("solution doesn't check out").combineMsg(ukmsg1)
        }
      } else ukmsg1
      val ukmsg = if (pr.currentState.isEmpty) {
        val bl = slvr.applyMain
        if (bl && slvr.getErrors.isEmpty && slvr.getUnsolvedVariables.isEmpty) {
          ukmsg2
        } else {
          HasError("solution doesn't check out").combineMsg(ukmsg2)
        }
      } else ukmsg2
      ukmsg match {
        case NoMsg() | WarningMsg(_) => ukmsg
        case HasError(_) => undo; ukmsg
      }
    }
  }

  /**
    * perform an undo step
    */
  def undo : Unit ={
    if (history.isEmpty) return
    val prold = history.remove(0)
    pr = prold
    slvr = slvr.currentStateObj.undoSlvr()
  }

}