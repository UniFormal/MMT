package info.kwarc.mmt.latex

import info.kwarc.mmt.api._
import utils._
import frontend._
import symbols._
import modules._
import documents._
import info.kwarc.mmt.api.objects.Obj.{getConstants, parseTerm}
import info.kwarc.mmt.api.opaque.{ObjFragment, OpaqueText, ScopeFragment, StringFragment}
import objects._
import presentation._
import notations._
import parser._

import scala.collection.immutable.Queue


/** helper functions for latex presenter */
object Common {
  def doConstantName(p: GlobalName) = {
    val mod = doLocalName(p.module.name)
    val name = doLocalName(p.name)
    "\\" + mod + "@@" + name
  }
  private def doLocalName(l: LocalName): String = l.steps.map {
    case SimpleStep(n) => Common.translateName(n)
    case ComplexStep(p) => doLocalName(p.name)
  }.mkString("@")

  /** translate each character in s according to by */
  private def translate(s: String, by: Char => Option[String]): String = s.map {c => by(c).getOrElse(c.toString)}.mkString("")
  
  /** translates a unicode-containing string into the latex equivalent */
  def translateDelim(s: String) = translate(s, c => utils.listmap(delimEscapes,c) orElse macroUnicodeMap(c))
  
  /** translates a string making up an MMT name into a latex name */
  def translateName(s: String) = translate(s, c => utils.listmap(commandEscapes, c) orElse rawUnicodeMap.get(c))
  
  /** escapes of characters within latex commands */
  private val commandEscapes = "\\_-1234567890".toList zip List("B", "U", "M", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Zero")
  /** escapes of characters within latex delimiters */
  private val delimEscapes = '\\' -> "\\backslash " :: '~' -> "\\sim " :: ' ' -> "\\;" :: "$#%&{}_^".toList.map(c => (c, "\\" + c))
  /** maintains a map of unicode-latex replacements, populated on initialization from the resource as jEdit abbreviations
   * later maps overwrite earlier ones; so make sure the resource always contain the non-standard commands (e.g., \ra) before their latex analogs  
   */
  private val rawUnicodeMap = new scala.collection.mutable.HashMap[Char,String]()
  private def macroUnicodeMap(c: Char): Option[String] = rawUnicodeMap.get(c).map(x => "\\" + x + " ")
  private val inverseUnicodeMap = new scala.collection.mutable.HashMap[String,String]
  /** this is not used by default; users can add it as a rule if they have difficulties typing Unicode characters in LaTeX */
  object LatexToUnicodeConverter extends LexerExtension {
    def apply(s: String, i: Int, firstPosition: SourcePosition): Option[Token] = {
      if (s(i) != '\\') return None
      var j = i+1
      val l = s.length
      while (j < l && s(j).isLetter) {j+=1}
      val commandName = s.substring(i+1,j)
      val command = "\\" + commandName
      val wsBefore = i == 0 || TokenList.isWhitespace(s(i-1))
      val t = inverseUnicodeMap.get(commandName) match {
        case Some(unicode) =>
          Token(unicode, firstPosition, wsBefore, Some(command))
        case None =>
          Token(command, firstPosition, wsBefore)
      }
      Some(t)
    }
    def trigger = Some("\\")
  }
  private def init: Unit = {
    val basicmap = UnicodeMap.readMap("unicode/unicode-latex-map")
    fillMap(basicmap)
  }
  init
  
  private def fillMap(map: List[(String,String)]): Unit = {
    map.foreach {case (c,r) =>
      // command starts with j
      val command = c.substring(1)
      if (r.length == 1) {
        val char = r(0)
        rawUnicodeMap(char) = command
        inverseUnicodeMap(command) = r
      } else {
        // better to ignore this because they can be useful in other contexts
        // throw GeneralError(s"expected single character in symbol map: $c|$r")
      }
    }
  }
}

import Common._

/**
 * compiles MMT to LaTeX by producing
 * * a sty-file for each theory
 * * containing a macro definition for each constant
 * 
 * type and definiens are ignored, only notations are used
 * 
 * This is 'compiling' in the sense that MMT/X is turned into LaTeX/X.
 * It is to be distinguished from visualizing presenters that turn MMT/X into LaTeX/MMT/X, e.g., by generating LaTeX that represent MMT source code.
 * A preliminary such presenter exists in commented-out code.
 */
class MacroGeneratingPresenter extends Presenter(new MacroUsingPresenter) {
  def key = "mmt-sty"

  override val outExt = "sty"
  
  def apply(e : StructuralElement, standalone: Boolean = false)(implicit rh : RenderingHandler): Unit = {
    e match {
      case t: Theory => doTheory(t)
      case d: Declaration => doDeclaration(d)
      case _ =>
    }
  }

  private def doTheory(dt: Theory)(implicit rh : RenderingHandler): Unit = {
    controller.simplifier(dt)
    rh << "% generated by MMT from theory " + dt.path + "\n"
    dt.meta foreach {m =>
      doDeclaration(PlainInclude(m, dt.path))
    }
    dt.getDeclarationsElaborated.foreach {
      case d => doDeclaration(d)
    }
  }

  private def doDeclaration(d: Declaration)(implicit rh : RenderingHandler): Unit = {
    d match {
      case c: Constant => doConstant(c)
      case i @ Include(id) =>
        // skip redundant includes
        if (i.isGenerated)
          return
        // ignore includes of theories written in scala 
        if (id.from.doc.uri.scheme contains "scala")
          return
        val arch = controller.backend.findOwningArchive(id.from).getOrElse {
          logError("cannot find archive holding " + id.from + " (ignoring)")
          return
        }
        val pLAbs = arch / outDim / "content" / archives.Archive.MMTPathToContentPath(id.from.mainModule).stripExtension
        val pLRel = arch.root.up.up.relativize(pLAbs)
        val pL = pLRel.segments.mkString("/")
        rh << "\\RequireMMTPackage{" + pL + "}\n"
      case _ =>
    }
  }
  
  private def doConstant(c: Constant)(implicit rh : RenderingHandler): Unit = {
    val not = c.notC.getPresentDefault
    var numArgs = not match {
      case None => 0
      case Some(tn) =>
        tn.arity.length
    }
    val notBody = not match {
      case None => Common.translateDelim(c.name.toString)
      case Some(tn) =>
        // if an InferenceMarker occurs, the generated macro expects an additional argument for the inferred type
        val dm = new DoMarkers(c.path, numArgs+1)
        val tnS = dm.doMarkers(tn.presentationMarkers)
        if (dm.infMarkerUsed)
          numArgs += 1
        tnS
    }
    val numArgsS = if (numArgs == 0) "" else "[" + numArgs.toString + "]"
    rh << s"\\newcommand{${doConstantName(c.path)}}$numArgsS{$notBody}\n"
  }

  /** helper class to encapsulate the state of doMarkers */
  private class DoMarkers(p: GlobalName, infMarkerPos: Int) {
    var infMarkerUsed: Boolean = false 
    /** convert notation markers into the body of a \newcommand */
    def doMarkers(ms: List[Marker]): String = {
      val msS = ms.map {
        case a: Arg => "#" + a.number.abs
        case a: ImplicitArg => s"\\mmt@implicit{#${a.number.abs}}"
        case s: SeqArg => "\\mmt@fold{" + doDelim(s.sep) + "}{" + "#" + s.number.abs + "}"
        case d: Delimiter => doDelim(d)
        case Var(n, _, Some(sep), _) => "\\mmt@fold{" + doDelim(sep) + "}{" + "#" + n + "}"
        case Var(n, _, None, _) => "#" + n
        case GroupMarker(elements) => "{" + doMarkers(elements) + "}"
        case ScriptMarker(main, sup, sub, over, under) =>
          var res = doM(main)
          over.foreach  {s => res = s"\\overset{${doM(s)}}{$res}"}
          under.foreach {s => res = s"\\underset{${doM(s)}}{$res}"}
          sup.foreach   {s => res = s"{$res}^{${doM(s)}}"}
          sub.foreach   {s => res = s"{$res}_{${doM(s)}}"}
          res
        case FractionMarker(above, below, line) =>
          val aboveL = doMarkers(above)
          val belowL = doMarkers(below)
          val command = if (line) "frac" else "Frac"
          s"\\$command{$aboveL}{$belowL}"
        case InferenceMarker =>
          infMarkerUsed = true
          "#" + infMarkerPos
        case m =>
          logError("unexpected notation marker: " + m)
          "ERROR"
      }
      msS.mkString("")
    }
    private def doM(m: Marker) = doMarkers(List(m))
  
    private def doDelim(d: Delimiter) = {
      val dL = Common.translateDelim(d.expand(p, Nil).text)
      s"\\mmt@symref{${p.toPath}}{$dL}"
    }
  }
  
/*
  private def requirePackage(p: MPath, bf: BuildTask): String = {
    controller.backend.findOwningArchive(p) match {
      case None => "% skipping import of unknown module " + p.toPath
      case Some(a) =>
        val conP = Archive.MMTPathToContentPath(p)
        val sty = (a / outDim / conP).stripExtension
        val relSty = utils.FileURI(bf.outFile).relativize(utils.FileURI(sty)).pathAsString
        s"\\RequirePackage{\\currfiledir $relSty}"
    }
  }
*/
}

/**
 * compiles MMT to sTeX by producing
 * a tex-file for each theory
 * containing a symdef definition for each constant
 */
class ModuleGeneratingPresenter extends Presenter(new MacroUsingPresenter) {
  def key = "mmt-stex"

  override val outExt = "tex"

  private val mathclassMap = UnicodeMap.readMap("unicode/latex-mathclass-map")

  def apply(structuralElement : StructuralElement, standalone: Boolean = false)(implicit rh : RenderingHandler): Unit = {
    structuralElement match {
      case theory: Theory => doTheory(theory, standalone)
      case declaration: Declaration => doDeclaration(declaration, standalone)
      case document: Document => doDocument(document, standalone)
      case _ =>
    }
  }

  private def doTheory(theory: Theory, standalone: Boolean)(implicit rh : RenderingHandler): Unit = {
    controller.simplifier(theory)
    if (standalone) {
      rh << s"% generated by MMT from theory ${theory.path}\n"
      rh << s"\\documentclass{article}\n"
      rh << s"\\usepackage{stex}\n"
      // Testing this package for use with special math symbols
      rh << s"\\libinput{preamble}\n"
      rh << s"\\begin{document}\n"
    }
    rh << s"\\begin{smodule}{${theory.name.toString}}\n"
    theory.meta foreach { mPath =>
      doDeclaration(PlainInclude(mPath, theory.path), standalone)
    }
    theory.getDeclarationsElaborated.foreach {
      declaration => doDeclaration(declaration, standalone)
    }
    rh << s"\\end{smodule}\n"
    if (standalone) {
      rh << s"\\end{document}\n"
    }
  }

  private def doDeclaration(declaration: Declaration, standalone: Boolean)(implicit rh : RenderingHandler): Unit = {
    declaration match {
      case constant: Constant => doConstant(constant, standalone)
      case i @ Include(id) if standalone =>
        // skip redundant includes
        if (i.isGenerated)
          return
        // ignore includes of theories written in scala
        if (id.from.doc.uri.scheme contains "scala")
          return
        val importString = buildIncludeString(id.from, standalone)
        rh << importString
      case _ =>
    }
  }

  private def buildIncludeString(mPath: MPath, standalone: Boolean): String = {
    val archive = controller.backend.findOwningArchive(mPath).getOrElse {
    logError("cannot find archive holding " + mPath + " (ignoring)")
    return "Could not build the Include String"
  }
    val pLAbs = archive / outDim / "content" / archives.Archive.MMTPathToContentPath(mPath.mainModule).stripExtension
    val pLRel = archive.root.up.up.relativize(pLAbs)
    val pL = pLRel.segments.mkString("/")

    // Testing in MathHub-dir, importmodule-string has to be changed accordingly ($-escapes causes errors in path recognition)
    val archivePath = archive.archString
    val filePath = pL.replaceFirst(archivePath, "").replaceFirst("/", "")
    val moduleName = pL.slice(pL.lastIndexOf("/") + 1, pL.length).replace("$", "")
    val modulePath = filePath.slice(0, filePath.lastIndexOf("/")) + s"?$moduleName"
    if (standalone) {
      println(s"\\importmodule[$archivePath]{$modulePath}")
      s"\\importmodule[$archivePath]{$modulePath}\n"
    }
    else {
      println(s"\\usemodule[$archivePath]{$modulePath}")
      s"\\usemodule[$archivePath]{$modulePath}\n"
    }
  }

  private def doConstant(constant: Constant, standalone: Boolean)(implicit rh : RenderingHandler): Unit = {
    val constantName = constant.name.toString
    // Handle alias(es)?
    // val constantAlias = constant.alias
    var symdef = s"\\symdef{$constantName}[name=$constantName"
    val notation = constant.notC.getParseDefault
    notation match {
      case None => symdef = symdef + s"]{$constantName}"
      case Some(textNotation: TextNotation) =>
        val numArgs = textNotation.arity.length
        // possible args: i, a, b, B. Need proper handling
        val args = numArgs match {
          case 0 => "]"
          case n if n > 0 => s",args=$n]"
        }
        // assoc not important for now, focus on notation only
        // possible assoc: pre, bin, binl, binr, conj. Need proper handling
        // val assoc = if (numArgs > 1) ",assoc=bin" else ",assoc=pre"
        // precedence not important for now, focus on notation only
        // precedence in sTeX is handled differently, need to convert
        // val prec = s",prec=${textNotation.precedence.toString}"
        val stexNotation = doNotation(textNotation, constant.path)

        symdef = symdef + args + stexNotation
      }
      if (standalone) {
        rh << s"$symdef\n"
      }
      else {
        rh << s"Let $constantName be a constant such that...\n"
      }
  }

  // ToDo: symbol "brackets" in mmt?mmt seems not right
  private def doNotation(textNotation: TextNotation, constantGlobalName: GlobalName): String = {
    println(s"Constant: $constantGlobalName")
    println(s"Notation: $textNotation")

    var notation = "{"

    val markers = textNotation.presentationMarkers

    markers.foreach {
      case argument: Arg =>
        notation = notation + s"#${argument.number} "
      case simpSeqArg: SimpSeqArg =>
        println(s"DEBUG: $textNotation")
        println(s"  SimpSeqArg: $simpSeqArg")
      case implicitArg: ImplicitArg =>
        println(s"DEBUG: $textNotation")
        println(s"  ImplicitArg: $implicitArg")
      case labelSeqArg: LabelSeqArg =>
        println(s"DEBUG: $textNotation")
        println(s"  LabelSeqArg: $labelSeqArg")
      case scriptMarker: ScriptMarker =>
        println(s"DEBUG: $textNotation")
        println(s"  ScriptMarker: $scriptMarker")
      case fractionMarker: FractionMarker =>
        println(s"DEBUG: $textNotation")
        println(s"  FractionMarker: $fractionMarker")
      case delimiter: Delimiter =>
        val translatedDelimiter = doDelimiter(delimiter, constantGlobalName)
        notation = notation + translatedDelimiter
      case variable: Var =>
        notation = notation + s"${variable.toString} "
    }

    notation + "}"
  }

  private def doDelimiter(delimiter: Delimiter, constantGlobalName: GlobalName): String = {
    val translatedDelimiter = Common.translateDelim(delimiter.expand(constantGlobalName, Nil).text)
    val delimWithClassWrapper = decideDelimiterClass(translatedDelimiter)
    delimWithClassWrapper
  }

  private def decideDelimiterClass(delimiterString: String): String = {
    val trimmedDelimiter = delimiterString.trim()
    var wrappedDelimiter = catchUnknownMacros(trimmedDelimiter)

    var debugFoundClass = false
    mathclassMap.foreach { symbolClassPair =>
      if (symbolClassPair._1 == wrappedDelimiter) {
        wrappedDelimiter = s" ${symbolClassPair._2}{\\maincomp{$wrappedDelimiter}} "
        debugFoundClass = true
      }
    }
    if (!debugFoundClass) {
      println(s"No class found for delimiter, add to mathclassMap: $wrappedDelimiter")
    }

    wrappedDelimiter
  }

  // Some macros from unicode-latex-map do not get recognized, convert to a accepted equivalent
  private def catchUnknownMacros(delimiter: String): String = {
    delimiter match {
      case "\\der" => "\\rightassert"
      case "\\rA" => "\\rightarrow"
      case "\\lrA" => "\\leftrightarrow"
      case "\\lbracket" => "\\lbrack"
      case "\\rbracket" => "\\rbrack"
      case "\\{" => "\\lbrace"
      case "\\}" => "\\rbrace"
      case _ => delimiter
    }
  }

  // Exclude directories from getting handled like documents
  private def doDocument(document: Document, standalone: Boolean)(implicit rh : RenderingHandler): Unit = {

    if (standalone) {
      rh << s"% generated by MMT from document ${document.path}\n"
      rh << s"\\documentclass{article}\n"
      rh << s"\\usepackage{stex}\n"
      // Testing this package for use with special math symbols
      rh << s"\\libinput{preamble}\n"
      rh << "\\begin{document}\n"
    }
    document.getDeclarations foreach {
      // Sections?
      case nestedDocument: Document => doDocument(nestedDocument, standalone = false)
      // Handle namespaces?
      case mRef: MRef => controller.globalLookup.get(mRef.target) match {
        case theory: Theory =>
          val importString = buildIncludeString(mRef.target, standalone = false)
          rh << importString
          rh << s"Theory: ${theory.name}\n"
          doDocument(theory.asDocument, standalone = false)
        case view: View => doDocument(view.asDocument, standalone = false)
      }
      case sRef: SRef => controller.globalLookup.get(sRef.target) match {
        case declaration: Declaration => doDeclaration(declaration, standalone = false)
        case _ =>
        }
      case opaqueText: OpaqueText => doOpaque(opaqueText)
      case _ =>
    }
    if (standalone) {
      rh << "\\end{document}\n"
    }
  }

  private def doOpaque(opaqueText: OpaqueText)(implicit rh: RenderingHandler): Unit = {
    // All lines except the first are indented, needs clear formatting
    opaqueText.text match {
      case stringFragment: StringFragment => {
        rh << s"${stringFragment.value}\n"
      }
      // case ObjFragment(o) => doObj(o)
      case objectFragment: ObjFragment => {
        rh << s"${objectFragment.toString}\n"
      }
      // case ScopeFragment(body) => body.map(doOpaque).mkString()
      case scopeFragment: ScopeFragment => {
        rh << s"${scopeFragment.toString}\n"
      }
    }
  }
}

/**
 * convert a term into a LaTeX expression (using lots of \ { and })
 * 
 * the LaTeX is relative to the macros generated by [[MacroGeneratingPresenter]] 
 */
class MacroUsingPresenter extends ObjectPresenter {
  def apply(o: Obj, origin: Option[CPath])(implicit rh : RenderingHandler): Unit = {
    val con = origin match {
      case Some(CPath(p: ContentPath,_)) => Context(p.module)
      case _ => Context.empty
    }
    rh << doObj(o)(con)
  }

  /** translates an MMT name into a LaTeX name
   *  some subtleties of complex steps are still ignored, but the resulting names should be unique in most cases
   */
  private def doObj(obj: Obj)(implicit context: Context): String = {
    val objS = obj match {
      case OMS(p) => doConstantName(p)
      case OMV(n) => n.toPath
      case t @ ComplexTerm(_, _, _, _) =>
        val tS = controller.pragmatic.makePragmatic(t)(p => Presenter.getNotations(controller, p, true)) match {
          case None =>
            val ComplexTerm(p, subs, con, args) = t
            Presenter.getNotations(controller, p, true).headOption match {
              case Some(not) =>
                doComplexWithNotation(t, p, subs, con, args, not)
              case None =>
                doComplexDefault(p, subs, con, args)
            }
          case Some(tP) =>
            val PragmaticTerm(p, subs, con, args, not, _) = tP
            doComplexWithNotation(t, p, subs, con, args, not)
        }
        "\\mmt@group{" + tS + "}"
      case l: OMLITTrait =>
        "\\mmt@lit{" + l.toString + "}"
      case o: OML =>
        doObj(o.vd) 
      case VarDecl(n, _, tp, df, _) =>
        val nL = n.toPath
        val (tpLatex,tpInfText) = tp match {
          case None => ("","")
          case Some(t) =>
            val tL = doObj(t)
            val inferred = parser.SourceRef.get(t).isEmpty
            val tT = if (inferred) controller.presenter.asString(t) else ""
            (tL,tT)
        }
        val dfL = df match {
          case None => ""
          case Some(t) => doObj(t)
        }
        // if the type was inferred, we add its text rendering as an optional argument (e.g., to display as a tooltip)
        s"{\\mmt@vardecl[$tpInfText]{$nL}{$tpLatex}{$dfL}}"
      case s: Sub =>
        doObj(VarDecl(s.name, df = s.target))
      case t =>
        logError("unexportable: " + t)
        "\\mmt@error{unknown object}"
    }
    objS
  }

  private def doComplexWithNotation(strict: Term, p: GlobalName, subs: Substitution, con: Context, args: List[Term], not: TextNotation)
                                   (implicit context: Context): String = {
    val arity = not.arity
    val subsG = arity.groupArgs(subs.map(_.target), true)
    val conG = arity.groupVars(con)
    val argsG = arity.groupArgs(args, false) 
    var res = doConstantName(p)
    def append(l: Seq[String]): Unit = {
      res += l.mkString("{",",","}")
    }
    subsG.foreach {a =>
      val aS = a map doObj
      append(aS)
    }
    var extCon = context
    conG.foreach {c =>
      val cS = c.variables map {vd =>
        val r = doObj(vd)(extCon)
        extCon ++= vd
        r
      }
      append(cS)
    }
    argsG.foreach {a =>
      val aS = a map {x => doObj(x)(extCon)}
      append(aS)
    }
    // add the inferred type as a final argument
    if (not.markers exists {m => m.atomicDescendants contains InferenceMarker}) {
      val strictI = checking.Solver.infer(controller, context, strict, None) match {
         case Some(tp) =>
            doObj(tp)
         case None =>
            "\\mmt@error{type inference failed}"
      }
      res += "{" + strictI + "}"
    }
    res
  }
  private def doComplexDefault(p: GlobalName, subs: Substitution, con: Context, args: List[Term])(implicit context: Context): String = {
    val name = doConstantName(p)
    val subsS = (subs map doObj).mkString(",")
    val conS = (con mapVarDecls {case (vdCon,vd) => doObj(vd)(context++vdCon)}).mkString(",")
    val argsCon = context ++ con
    val argsS = (args map {a => doObj(a)(argsCon)}).mkString(",")
    s"\\mmt@complex{$name}{$subsS}{$conS}{$argsS}"
  }
}
