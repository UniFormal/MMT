package info.kwarc.mmt.latex

import info.kwarc.mmt.api._
import utils._
import frontend._
import symbols._
import modules._
import documents._
import objects._
import parser._
import presentation._
import notations._
import frontend.actions._

/** helper functions */
object MMTTeX {
  /** represents the special constant names generated by mmttex.sty counterpart when representing anonymous objects as defined constants */
  case class ObjectID(name: String) {
    def toName = s"${ObjectID.prefix}$name"
    def toLatex = "\\csname " + toName + "\\endcsname"
  }
  object ObjectID {
    val prefix = "mmt@"
    def unapply(s: String): Option[ObjectID] = {
       if (s.startsWith(prefix)) {
         Some(ObjectID(s.substring(prefix.length)))
       } else
         None
    }
  }
}

import MMTTeX._

/**
 * to be used in conjunction with mmttex.sty
 * 
 * converts job.tex.mmt, which is generated by mmttex.sty when running latex,
 * into job.tex.mmt.sty, which is included by mmttex.sty when running latex a second time
 * 
 * @param tex the tex file 
 */
case class MMTTeX(tex: File) extends Action {
   def toParseString = s"mmttex $tex"
   
   def apply(): Unit = {
     val base = DPath(FileURI(tex))
     val mmt = tex.addExtension("mmt")
     val sty = mmt.addExtension("sty")
     val eh = new ErrorLogger(report)
     controller.getMathHub.foreach {mh => controller.backend.openArchive(mh.local)}
     val ps = ParsingStream.fromFile(mmt, dpathOpt = Some(base), formatOpt = Some("mmt"))
     log(mmt.toString + " -> " + sty.toString)
     controller.delete(base)
     val doc = controller.read(ps, true)(eh)
     //log(doc.toString)
     val writer = new StyWriter(base, sty, eh)
     writer.doDocument(doc)
     writer.jobFile.done
   }

   /** scope that holds all global arguments needed while writing the sty file */
   private class StyWriter(dpath: DPath, sty: File, eh: ErrorHandler) {
     val presenter = new MacroGeneratingPresenter
     initOther(presenter)
     val jobFile = new FileWriter(sty)

     def doDocument(doc: Document): Unit = {
       doc.getModulesResolved(controller.globalLookup) foreach doModule
     }

     private def doModule(m: Module): Unit = {
        controller.simplifier(m)
        m match {
          case dt: Theory => dt.meta.foreach {mt =>
            presenter(PlainInclude(mt, m.path))(jobFile)
          }
          case _ =>
        }
        val decls = m.getDeclarations
        decls.foreach {
          case c: Constant =>
             val name = c.name.toPath
             name match {
               case ObjectID(id) =>
                 c.df match {
                   case Some(df) =>
                     val dfL = presenter.asString(df, Some(c.path $ DefComponent))
                     jobFile << s"\\expandafter\\def${id.toLatex}{$dfL}\n"
                   case None => // malformed mmt file: generate error/warning
                 }
               case _ =>
                 presenter(c)(jobFile)
             }
          case nm: NestedModule =>
             doModule(nm.module)
          case i @ Include(id) =>
            if (id.from.doc == dpath) {
               // skip locally defined theories
            } else {
              presenter(i)(jobFile)
            }
          case _ =>
        }
     }
   }
}

class MMTTeXActionParser extends ActionCompanion("run mmttex", "mmttex") {
  def parserActual(implicit state: ActionState) = Action.file ^^ {f => MMTTeX(f)}
}
