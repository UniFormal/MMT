package info.kwarc.mmt.jedit

import errorlist._
import info.kwarc.mmt.api._
import info.kwarc.mmt.api.archives.source
import info.kwarc.mmt.api.frontend._
import info.kwarc.mmt.api.objects._
import info.kwarc.mmt.api.parser._
import info.kwarc.mmt.api.utils.MyList._
import info.kwarc.mmt.api.utils._

/**
 * sends MMT errors directly to jEdit ErrorList
 * @param file the source file, in which the errors are found
 */
class ErrorListForwarder(errorSource: DefaultErrorSource, controller: Controller, src: File) extends ErrorHandler {
   def reset {
      errorSource.removeFileErrors(src.toString)
   }
   protected def addError(e: Error) = e match {
      case s: SourceError =>
         //generated by parsers
         val tp = if (s.level == Level.Warning) ErrorSource.WARNING else ErrorSource.ERROR
         val reg = s.ref.region
         val pos = reg.start
         // We permit the case that errors are found in other files than the current one. So we compute the file path
         val file = controller.backend.resolveLogical(s.ref.container) match {
            case Some((a, p)) => (a / source / p).toString
            case None => s.ref.container match {
               case utils.FileURI(f) => f.toString
               case u => u.toString
            }
         }
         val error = new DefaultErrorSource.DefaultError(errorSource, tp, file, pos.line, pos.column, pos.column + reg.length, s.mainMessage)
         s.extraMessages foreach {m => error.addExtraMessage(m)}
         errorSource.addError(error)
      case e: Invalid =>
         //generated by checkers
         var mainMessage = e.shortMsg
         var extraMessages : List[String] = Nil
         val cause: metadata.HasMetaData = e match {
            case e: InvalidObject => e.obj
            case e: InvalidElement => e.elem
            case e: InvalidUnit =>
               val steps = e.history.getSteps.reverse
               extraMessages = steps.map(_.present(o => controller.presenter.asString(o)))
               val decl = controller.localLookup.get(e.unit.component.get.parent)
               // WFJudgement must exist because we always start with it
               // find first WFJudegment whose region is within the failed checking unit
               // but maybe lastWFJ.wfo has lost its region through simplification?
               SourceRef.get(decl).flatMap {bigRef =>
                  steps.mapFind {
                     case j: WFJudgement =>
                        SourceRef.get(j.wfo) flatMap {smallRef =>
                           if (bigRef contains smallRef) {
                              mainMessage += ": " + controller.presenter.asString(j.wfo)
                              Some(j.wfo)
                           } else
                              None
                        }
                     case _ => None
                  }
               }.getOrElse(decl)
         }
         val ref = SourceRef.get(cause) getOrElse {
            mainMessage = "error with unknown location: " + mainMessage
            SourceRef(utils.FileURI(src), SourceRegion(SourcePosition(0,0,0), SourcePosition(0,0,0)))
         }
         val reg = ref.region
         val error = new DefaultErrorSource.DefaultError(errorSource, ErrorSource.ERROR, src.toString,
               reg.start.line, reg.start.column, reg.start.column + reg.length, mainMessage)
         extraMessages foreach {m => error.addExtraMessage(m)}
         errorSource.addError(error)
      case e: Error =>
         // other errors, should not happen
         val error = new DefaultErrorSource.DefaultError(
             errorSource, ErrorSource.ERROR, src.toString, 0, 0, 1, "error with unknown location: " + e.getMessage
         )
         e.toStringLong.split("\\n").foreach {m => error.addExtraMessage(m)}
         errorSource.addError(error)
   }
}
